1. 获得代理类的语句：
    Object proxy = Proxy.newProxyInstance(null, new Class[]{Comparable.class, ....}, handler);
第一个参数表示：ClassLoad类加载器
第二个参数表示：这个代理类所代理的接口，即汇总了多少接口，主要说明，这个代理类代理多少接口的方法，此外还有Object类的全部方法
第三个参数表示：调用处理器（方法调用处理器），是代理类的唯一实例，这个处理器必须实现 InvocationHandler 函数是接口，此接口有一个
Objcet invoke(Object proxy, Method method, Object[] args);
调用处理器是代理的核心，最最核心的内容，同时它也表示的是代理类的实例域。
invoke方法的：
第一个参数表示代理对象，因为，同一个调用处理器可以作为不同代理类的实例域，所以，这个参数是确实代理实例的
第二个方法是要代理的接口的方法，当调用method.invoke(objcet...objects) 时，它的第一个参数作为原方法的隐式参数，
后面的参数作为显示参数，如果要调用代理的原方法，显示参数一般就用invoke的第三个实参作为实参传递。
所以，注意！！！如果一定要调用原方法：method.invoke(objcet... paramt),则第一个参数是隐式参数，所以这个实例一定要实现这个方法
的接口。

2. 代理类没有名字，名字由系统给出，一个代理类由类加载器和一组接口唯一确定。只要这两个参数一致，就是同一个代理类。而第三个参数，
调用处理器只是表示代理类的实例域，显然，同一类的不用实例，实例域可以不同！！

3. 对代理类的方法调用是需要根据接口进行强制类型转换的，如果代理类只代理了一个接口，这可可以在创建代理类时进行类型转换。如果代理
类代理了多个接口可以在使用某个特定的接口的方法时在进行转换，而在创建代理类时不要急着类型转换。
因为method.invoke()方法的第一个参数是表明实现了method方法的实例，而，Method.invoke()的第一个形参的类型是object类型的，所以
是绝对没有实现其他接口的，故需要在适当的地方进行强制类型转换。