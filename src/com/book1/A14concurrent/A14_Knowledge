                                *************
                                ** 并发技术 **
*****************************************************************************************************
理解:
1. 多进程：执行多个程序，每个程序有一套自己的完整数据。 多线程：一个程序多个任务，线程之间可以共享本程序的所有数据。
2. 线程的基本数据域：
    1. Thread.State 线程状态。
    2. Thread.UncaughtExceptionHandler 未捕获异常处理器 。
    3. 线程的优先级，三个预定义的常量，也可用用1~10表示。
    4. 中断标志：当某个线程的中断标志为true时，如果线程被中断检查识别，则线程处于中断状态，即相应了中断标志
    ，但此时线程不一定终止。如果线程处于阻塞，则无法识别中断状态(此识别是系统在某个时间点自动检查，不是程序
    的代码所控制的检查，即不是isIntrrupt()检查中断标志。因为线程识别中断状态是线程自己识别，不是别的线程帮助
    识别，而isIntrrupt()可以在任意线程上调用）
    还有重点：中断和终止没有半毛钱关系。

3. 中断异常异常的发生：
    1. 设置处于阻塞状态的线程的中断状态，此时设置失败，抛出InterruptExcetion

4. 线程状态：public static final Thread.State xxx
    NEW：尚未启动的线程处于此状态。
    RUNNABLE：在Java虚拟机中执行线程，称为可运行状态。
    BLOCKED：线程在阻塞队列内的状态，称为阻塞状态。进入阻塞队列的原因：
        1.系统线程之间调度，如果有多个线程在同一时刻都是RUNNABLE,但是在一个特定的时刻，只有一个线程获
        得cup的使用权（针对单CPU机器），所以此时其他没有获得使用权的线程将状态置为BLOCKED
        2.当某个线程运行时需要某个资源，但该资源被加锁，且其他线程占用这锁时，此线程则会进入BOLOCKED状态
        3. 当前线程通过条件对象调用await()方法，这当前线程进入条件的等待集，与前面两种性质不同。
    WAITING：等待被唤醒，或等待被interrupt()宣布终止（通过抛出InterruptedException结束线程）。
    TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。wait(delay)
    TERMINATED：运行完的线程。注意在timer.schedule(new TimerTask(), daley, longtime)结构中，代码每次
    执行都是重新启动了线程。
public Thread.State getState()

5. 多线程的运行由操作系统的线程调度器控制，系统为每个线程的运行提供短暂的时间片，所以任何一个线程都有可能还没有
完成任务就被其他线程剥夺运行机会，从而等待线程下次获得运行的机会（此时未获得运行机会的线程此时的state为BOLCKED。
线程的真正并行依靠系统需要多处理器

6. 被阻塞状态随时有可能进入可运行状态。而等待状态如果等待时间为0，则进入永久等待状态直到通知，而有一种方法可以让其会到
可运行状态：让等待的线程抛出一个异常，并捕获这个异常，则可以再次让此线程再次进入可运行状态，如果等待时间不为0，
则至少过了等待时间才有可能进入可运行状态。

 7. 线程优先级高度依赖于底层操作系统。当虚拟机依赖于宿主机平台的线程实现机制时，java线程的优先级被映射到宿主机
 平台的优先级上，优先级个数可能更多，或者更少。例如：Windows有7个级别的优先级，Linux提供的java虚拟机无优先级。
 所以，不要将程序功能构建的正确性依赖于优先级。
 用Theead类的：public final void setPriority(int newPriority)更改此线程的优先级，
 public final int getPriority()返回此线程的优先级。

 8. 守护线程：为其他线程提供服务，不应该在此线程访问固有资源。
 public final void setDaemon(boolean on)将此线程标记为daemon线程或用户线程。 当运行的唯一线程都是守护进程线程时，
 Java虚拟机将退出。 线程启动前必须调用此方法。

9. 为捕获异常处理器：Thread.UncaughtExceptionHandler 是Thread类的内部函数式接口，其方法为：
uncaughtException(Thread t, Throwable e) ，当给定的线程由于给定的未捕获异常而终止时调用方法。
（可参考A14_API.txt);
程序默认的处理器 < 线程组的处理器 < 线程自己的处理器

同步
10：竞争条件：多个线程存取同一资源.
11. 锁对象: ReentrantLock类
锁对象是某个类的数据域，所以不同对象的锁，是不同锁（除了static），一个锁，在一个时刻，只能被一个线程锁拥有，
即，但锁是可以重入的，即同一个线程可以多次获得同一个锁，此时有一个计数器来标志锁的获得次数。被一个锁保护的代码
可以调用使用相同的锁的方法。

12. 条件对象：（决解线程获得锁，在某些情况下不能做正确操作的情况，即排除条件之外的决解方法）一个锁，可以有一个
或多个相关的条件对象。可以用Lock接口的newCondition方法获得Condition类的对象。
条件对象的await() 和 signalAll()分别使当前线程进入条件等待集和移除条件等待集。当线程从条件等待集移出时，一旦
对象锁处于可用状态，则移出的线程在获得锁需要的锁之后，会从之前的await()方法返回，继续执行后续任务。但是线程应该注意此时
条件是否满足！！

13. synchronized: 代表获得了此对象的内部锁，每个对象都有一个内部锁。wait()：相当于外部锁的条件
对象调用了await()。由于使用某个锁的条件对象的同时，线程再此之前必须获得了这个条件对象的锁先，所以，await()的使用必须
在获得外部对象锁之后。同理，wait的使用也是绑定在synchronize之上的，即synchronized与wait必须是同一对象之上。

 14. 同步阻塞：能够使当前对象获得其他对象的锁。结构
 synchronized (object){
     //code
 }
 锁住的是一个代码块，而不是方法，可以在集合中保证多步操作的原子性。如多次调用set(),或set与集合的其他操作结合的操作组

 15. 监视器：特殊的类，局限更多。私有域，拥有内部锁，锁方法，任意多相关条件。

 volatile域：volatile关键字目的就是为了保证变量在java内存中的可见性，就是一旦变量被修改，其他线程会立即得知这个改变。
 对于多CPU的的机器，在处理多线程的时候，可以在同一时刻执行不同线程的语句，所以，有可能在同一时刻读写同一变量。用volatitl
 修饰的变量，可以保证在每一次读写的时候，volatile都是最新的。在《深入理解java虚拟机》一书中讲到，线程对volatile修饰的变
 量的use动作和load、read操作相关联，必须连续出现；所以使用volatile而不是synchronized关键字的唯一场景就是：所有线程对变量
 的修改均和变量的当前值无关，要的就是最新结果（或者保证只有一个线程能够修改变量的值）

16.线程局部变量:public static final ThreadLocal<T> data = ThreadLocal.withInitial(() -> new T(....));
注意T要用实际类型。
通过data.get():获得属于当前线程的的局部变量。
通过data.get():修改属于当前线程的局部变量。
通过data.remove:删除当前线程局部的局部变量。
（参考：A04ThreadLocal.java)

17. 锁测试：tryLock() 方法。如果使用lock方法获得锁的的线程被中断，则该线程将进入阻塞状态，不能自动继续参与锁竞争，直到signal方法被调用。
tryLock方法再竞争锁的时候，可以会立即返回false，这使得有机会通过这个开关，让此线程继续运行，且还能参与抢占式竞争，
一旦所需的锁未被使用，则会以更高的概率抢下这个锁，然后使tryLock方法返回true。且在抢夺锁的过程中，如果此线程被中断
则抛出InterruptedException异常。不会因为阻塞导致死锁！
(参考代码：A05LockAndInterrupt.java）

18. 原子性：包含众多类。（该技术暂不学习）。
19. 读写锁：太深奥

20. 阻塞队列







***********************************************************************************************************
总结